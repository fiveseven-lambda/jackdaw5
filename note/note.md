# mod pos
エラー出力のための位置情報を扱うモジュール

## struct CharPos
ソースコード中での文字の位置（ `line` 行目 `column` 文字目）を 0-indexed で表す．エラー出力の段階で 1-indexed に直す．

## struct Pos
ソースコード中でのトークンや式（複数文字／複数行にわたる）の位置を， `start: CharPos` から `end: CharPos` までの半開区間として表す．エラー出力の段階で閉区間に直す．

### impl Add
A, B を式やトークンとし，位置がそれぞれ `a: Pos`，`b: Pos` として得られているとする．ソースコード内で A と B が並んでいるとき， `a + b` で AB を合わせた範囲が得られるようにする．このとき，片方が `Option<Pos>` でもかまわないものとする．
注意： `a + b` と `b + a` は同じとは限らない．足し算は必ず「左のトークン」+「右のトークン」の順で行わねばならない．

# mod error
## enum Error
エラー．
面倒をさけるため， `enum Error` は参照をもたず，全てのメンバを所有することにする．よって，エラーメッセージにコピー不可能な値（たとえば `String` 型の変数名）を含めるときは `.clone()` することになる．

# mod token
## struct Token
トークンの種類を表すメンバ `name: TokenName` 
トークンに対応する，ソースコード中の文字列を表すメンバ `lexeme: String` 
ソースコード中での `lexeme` の位置を表すメンバ `pos: Pos`
## enum TokenName
### Identifier
識別子． `'A'..='Z'` `'a'..='z'` `'0'..='9'` `'_'` `'$'` で構成された文字列．ただし先頭は `'0'..='9'` でない．
### Number
数値リテラル．
### String
文字列リテラル． `"` で囲む．バックスラッシュによるエスケープとして， `\n` `\"` `\*` などを用意する．
### Operator
演算子．

# mod lexer
## struct Lexer
入力を受け取り，トークンに分割する．

標準入力（インタラクティブ環境）とファイル入力（スクリプト実行）のいずれにも対応できるように，入力は `BufRead` トレイトを介して読む（メンバ `reader: BufRead` ）．また，インタラクティブのときはプロンプト '> ' を出力する（メンバ `prompt: bool` ）．

`Lexer` は，トークンを格納するキューをもつ（メンバ `queue: VecDeque<Token>` ）．キューからトークンが取り出されてキューが空になったら， `Lexer` は次の行を読んでトークンをキューにプッシュする．

基本的には行単位で読むが，ブロックコメントは複数行にまたがりうる．よって「今ブロックコメントの途中である」という情報を保存する．メンバ `comment: Vec<CharPos>` が空でないならブロックコメントの途中である．

また，トークンには `Pos` を乗せるので，「今何行目か」はメンバ `line: usize` としてもっておく．

### fn read_line
入力を一行読み，トークンへと分割してからキューにプッシュする．

読み込んだ行を `s: String` とする．このとき， `s` の末尾は `'\n'` (0x0A) とは限らない（ EOF のときが例外となる）． `BufRead::read_line` は読んだバイト数を返す．これが 0 ならば EOF に達しており，それ以外のとき `s` は空でない．

トークンへの分割に失敗したときや，文字列リテラル／ブロックコメントが終了しないまま EOF に達したときは， `Err` を返す．正常に終わったとき， EOF に達していれば（ `read_line` の返り値が 0 ならば） `Ok(false)` を返し，そうでないときは `Ok(true)` を返す．このとき，最後のトークンがプッシュされ忘れることのないように注意する．

`s` は `iter = s.char_indices().enumerate().peekable()` によって走査する（ `.peekable()` はブロックコメントの処理に用いる）．パターン `(column, (index, c))` で受け取ると， `c` が今見ている文字， `index` がそのバイト位置， `column` が何文字目かを表す． `index` は `s` の部分スライスを得るために用い， `column` は位置情報（ `Pos` ）としてトークンに乗せる． `index` で位置情報を表したり `column` で部分スライスを得ようとしたりしないように注意する．

#### ラインコメント
ラインコメントは， `//` が見つかったときに `return Ok(true);` することで実現する．このとき， `//` 直前のトークンが `push` され忘れることのないように注意する．

#### ブロックコメント
`self.comment: Vec<CharPos>` が空でないとき，今見ている場所はブロックコメントの途中である．ブロックコメントはネスト可能であり， `self.comment` には今いる場所を囲っている `/*` `*/` の先頭（ `/` ）の位置（ `: CharPos` ）が浅い順に格納されている．

`c` が `'*'` のとき，ブロックコメントが終了する可能性がある． `.peek()` して次の文字が `'/'` ならば，それも読んだ上で `self.comment.pop()` する．

`c` が `'/'` のとき，ネストされてブロックコメントあるいはラインコメントが開始する可能性がある．`.peek()` して次の文字が `'*'` ならば，それも読んだ上で `'/'` の位置を `self.comment` に push する．一方次の文字が `'/'` ならば， `return Ok(true);` する．

#### 字句解析
`prev: Option<TokenName>`
`next: Option<TokenName>`

`c` がトークンの一文字目のときのトークンの種類を， `next` に代入する． `c` が空白文字ならば `None` とする．

